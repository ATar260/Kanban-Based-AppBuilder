// Versioning Utility Functions

import { VersionFile, VersionDiff, VersionTrigger } from './types';

/**
 * Generate a unique ID
 */
export function generateId(): string {
    return `${Date.now()}-${Math.random().toString(36).substring(2, 11)}`;
}

/**
 * Generate a simple hash for content (for change detection)
 */
export function hashContent(content: string): string {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
        const char = content.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    return Math.abs(hash).toString(36);
}

/**
 * Calculate diff between two version file sets
 */
export function calculateDiff(
    oldFiles: VersionFile[],
    newFiles: VersionFile[]
): VersionDiff {
    const oldMap = new Map(oldFiles.map(f => [f.path, f]));
    const newMap = new Map(newFiles.map(f => [f.path, f]));

    const added: string[] = [];
    const modified: string[] = [];
    const deleted: string[] = [];
    const unchanged: string[] = [];

    // Check new files
    for (const [path, newFile] of newMap) {
        const oldFile = oldMap.get(path);
        if (!oldFile) {
            added.push(path);
        } else if (oldFile.hash !== newFile.hash) {
            modified.push(path);
        } else {
            unchanged.push(path);
        }
    }

    // Check deleted files
    for (const path of oldMap.keys()) {
        if (!newMap.has(path)) {
            deleted.push(path);
        }
    }

    return { added, modified, deleted, unchanged };
}

/**
 * Check if there are any changes between two file sets
 */
export function hasChanges(oldFiles: VersionFile[], newFiles: VersionFile[]): boolean {
    const diff = calculateDiff(oldFiles, newFiles);
    return diff.added.length > 0 || diff.modified.length > 0 || diff.deleted.length > 0;
}

/**
 * Generate a version name based on trigger
 */
export function generateVersionName(
    trigger: VersionTrigger,
    ticketTitle?: string,
    versionNumber?: number
): string {
    const num = versionNumber ? `v${versionNumber}` : '';

    switch (trigger) {
        case 'ticket_done':
            return `${num} âœ… ${ticketTitle || 'Completed'}`.trim();
        case 'ticket_skipped':
            return `${num} â­ï¸ ${ticketTitle || 'Skipped'}`.trim();
        case 'ticket_failed':
            return `${num} âŒ ${ticketTitle || 'Failed'}`.trim();
        case 'manual_save':
            return `${num} ğŸ’¾ Manual save`.trim();
        case 'auto_save':
            return `${num} ğŸ”„ Auto-save`.trim();
        case 'build_start':
            return `${num} ğŸš€ Build started`.trim();
        case 'build_complete':
            return `${num} ğŸ‰ Build complete`.trim();
        case 'initial':
            return `${num} ğŸ“¦ Initial`.trim();
        default:
            return `${num} Version`.trim();
    }
}

/**
 * Generate a commit message for GitHub
 */
export function generateCommitMessage(
    trigger: VersionTrigger,
    ticketTitle?: string,
    ticketId?: string
): string {
    const emoji = {
        'ticket_done': 'âœ…',
        'ticket_skipped': 'â­ï¸',
        'ticket_failed': 'âŒ',
        'manual_save': 'ğŸ’¾',
        'auto_save': 'ğŸ”„',
        'build_start': 'ğŸš€',
        'build_complete': 'ğŸ‰',
        'initial': 'ğŸ“¦'
    }[trigger] || 'ğŸ“';

    const action = {
        'ticket_done': 'Complete',
        'ticket_skipped': 'Skip',
        'ticket_failed': 'Fail',
        'manual_save': 'Save',
        'auto_save': 'Auto-save',
        'build_start': 'Start build',
        'build_complete': 'Complete build',
        'initial': 'Initialize'
    }[trigger] || 'Update';

    let message = `${emoji} ${action}`;

    if (ticketTitle) {
        message += `: ${ticketTitle}`;
    }

    if (ticketId) {
        message += `\n\nTicket: ${ticketId}`;
    }

    message += '\n\nGenerated by Timbs A.I.';

    return message;
}

/**
 * Format bytes to human readable
 */
export function formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B';

    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
}

/**
 * Format relative time
 */
export function formatRelativeTime(dateString: string): string {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSecs = Math.floor(diffMs / 1000);
    const diffMins = Math.floor(diffSecs / 60);
    const diffHours = Math.floor(diffMins / 60);
    const diffDays = Math.floor(diffHours / 24);

    if (diffSecs < 60) return 'just now';
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;

    return date.toLocaleDateString();
}

/**
 * Generate a suggested repo name from project description
 */
export function generateRepoName(description: string): string {
    // Take first 50 chars, convert to lowercase, replace spaces with hyphens
    const base = description
        .substring(0, 50)
        .toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');

    // Add date suffix for uniqueness
    const dateStr = new Date().toISOString().split('T')[0];

    return `${base || 'project'}-${dateStr}`;
}

/**
 * Convert sandbox files to VersionFile format
 */
export function toVersionFiles(files: Array<{ path: string; content: string }>): VersionFile[] {
    return files.map(file => ({
        path: file.path,
        content: file.content,
        hash: hashContent(file.content),
        size: new Blob([file.content]).size,
        lastModified: new Date().toISOString()
    }));
}

/**
 * Calculate total size of version files
 */
export function calculateTotalSize(files: VersionFile[]): number {
    return files.reduce((sum, file) => sum + file.size, 0);
}
